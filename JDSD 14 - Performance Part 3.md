---
title: JDSD 14 - Performance Part 3
created: '2020-05-06T14:48:56.917Z'
modified: '2020-05-07T07:07:06.113Z'
---

# JDSD 14 - Performance Part 3

## Content Delivery Networks (CDNs)

* Content would be served from the nearest server for the fastest possible speed.
* All you do is update your DNS name servers to go through Cloudflare (or something similar)
  * The user makes a request to the edge server -> the edge server makes a response to the origin server -> the edge server replies to the client.
  * This server then caches the data after the initial request.
    * Each subsequent request would need to come from the edge server rather than the origin server.
* They are configured to handle higher traffic loads.
* They reduce spammers and bots etc.
* They can do load balancing between multiple servers.
* Very secure.
* Alternatives: Amazon CloudFront and Azure Content delivery network.
* Why are they needed?
  * Requesting data from New York to Singapore (over several routers) and back would have a lot of latency.
    * Instead the CDN would cache the files closer to the user.

## GZIP

* Aside from image optimisation, GZIP is probably the biggest for performance.
* GZIP makes the files smaller.
  * On an express server you can use `const compression = require('compression')` and then `app.use(compression())`
  * By default all modern browsers allow gzipping by default.
* Google Alternative: Brotli - Better compression, but not as widely used yet.

## Database Scaling

* Identify Inefficient Queries
  * Am I using the database efficiently?
  * Not having too many joins or too much info when you don't need it.
  * Only request what you absolutely need.
  * Use indexes to improve querying.
    * When we query a table, we have to access that entire discblock with the table.
    * To create an index we use `CREATE INDEX idx_name ON table_name (column_name)`
    * This makes for a faster query.
* Increase Memory
  * Improving the hardware the database is working on.
* Vertical Scaling (Redis, memcached)
  * Adding another service so your system used the resources better.
  * Adding another server with Reddis rather than the original server.
  * Caching so we use memory access rather than disk access.
* Sharding
  * Extremely hard to do and a tough problem.
  * Breaking down the website into different pieces.
    * For example: Rather than an entire list of users, split them into >30 and <30
* More Databases
  * More databases is more options.
  * Instead of giving 1000 requests to 1 database, split them over 3 databases.
* Database Type
  * Some databases are suited for one thing, some as another.


## Caching

* The process of storing some data in cache.
  * Think of it like a little package box to store info in so that we don't have to go all the way back to find that info.
* Computers
  * CPUs have a small bit of memory.
    * Closest and smallest memory storage but also the fastest.
  * RAM - Random Access Memories
    * Medium but quickish.
    * However, if the power goes out you lost it.
    * Not permanently stored.
  * Hard Disks
    * Longer distance and longer time, but cheaper and permanent storage.
* We do caching in variables, apis, in databases etc.
* Cache-busting: Webpack gets everything optimised for production, into optimised files with different numbers `main.8a92a300.css` for example.
  * The numbers only change when there is a change in the files.

### DIY Caching

* In Express we use two things for cache control:

```javascript

const app = express()
app.use(cors())
app.use('/static', express.static(path.join(__dirname, 'public'), {'maxage': '2h'}))

app.get('/hi', (req, res) => {
  res.header('Cache-control', 'public, max-age=86400')
  res.header('Content-Type', 'text/html');
  res.send(new Buffer('<h2>Test String</h2>'));
})

app.listen(3000, () => console.log('Example app listening on port 3000!'))

```
* Static, this is how you server static websites in express.
  * At this endpoint, server will return the static files.
* Maxage: How many seconds do you want the browser to remember the cache?
* Etag: A randomly generated hash that lets the file know that nothing has changed.
  * It is automatically generated by Express.
* Buffer allows us to send HTML strings that can be read by the browser.
  * This is the under-the-hood of how node is serving static files.
* 3 Caching Resources:
  * https://medium.freecodecamp.org/the-hidden-components-of-web-caching-970854fe2c49
  * https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching
  * https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers

## Load Balancing

* Balancing multiple requests at the same time and distribute them.
* Most companies use: Apache/Nginx - Very simple, give me a request, send something back.
  * We can use them as load balancers.
* Our Spa > Nginx -> Server 1, 2 or 3
* When you have enough users that the server can't handle, you need a load balancer.

### Using Nginx

* Most companies like Amazon and DigitalOcean already have ready to go load balanders.

```conf

worker_processes 1;

events { worker_connections 1024; }

http {
  upstream myapp1 {
    server web1:3000;
    server web2:3000;
    server web3:3000;
  }

  server {
    listen 80;
    location / {
      proxy_pass http://myapp1
    }
    location ~* \.(css|js|gif|jpeg|png)$ {
      expires 168h;
    }
  }
}

```
* `worker_process`: Can be whatever we want. Normally matches the number of cpus on your machine.
* worker connections is the max number of connections the worker can have.




